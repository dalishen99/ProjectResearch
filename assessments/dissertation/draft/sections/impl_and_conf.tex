\subsection{Honeypots}

\paragraph{} % 70

As we have seen previously, the analysis of Linux servers attacks requires collecting the 
maximum of information about each of them. In order to perform this task, I choose to put 
in place a honeypot software called Cowrie.
In this section will be explained how works a honeypot, how cowrie has to be configured and
finally how it is possible to extract useful attacks information from all collected data.

\subsubsection{Honeypots overview} % 421

\paragraph{}  

As seen during the literature and related works review, Honeypots are not a recent technics
and are still commonly used to trap attackers. Moreover, they can be used in multiple manners
to analyse different types of attacks. However, all of them are aimed at being undetectable 
by attackers. Indeed, honeypots software are built to receive attacks from real attackers
who wants to compromise a vulnerable machine and confine the attack to a controlled. 
environment. Hence, the configuration part of this type of tool and its security has to be
constantly monitored. A honeypot containing an unknown vulnerability (also called 0day) or
with incorrect settings, could be exploited by attackers and consequently lead
the machine to be compromised. 

Multiple systems can be used and some honeypots project, for instance, are able to be
installed on smartphones by using a tool such as HoneyDroid. Moreover, the HoneyNet Project 
gather security specialist that use multiple types of honeypots in order to collect data 
and report their knowledge about detected attacks on all platforms. They also developed 
various and sundry tools such as HoneySnap, a script used to extract malicious events from 
large logs generated by their honeypots, and allowing to understand attacker's methodology 
on the inside of the compromised system.

Honeypots can also be associated together and create HoneyNets. Unlike a honeypot that can
be installed on a system in production inside a complete network as a sensor or alone on a
separate machine, a honeyNet is composed of multiple honeypots. Each of them can allow to
detect and analyse more complex attacks in a large network closer to reality for a company
than a single machine.

In order to be attacked a honeypot has to be vulnerable and accessible remotely. There are a
large number of possible vulnerabilities depending on the system targeted. Each of them can
allow attackers to execute more or less critical tasks such as obtained a root access to
a server. A known honeypots technics, to perform this tasks, is to emulate a fake Secure Shell
(SSH) access. This service is used to obtain a remote secure shell from a server, in order
to monitor it. Indeed, this remote shell can be accessed by knowing a username and its 
associated password, available on the server. Once the honeypot emulates a fake SSH access it
will allow creating multiple valid identifiers allowing an attacker to access to a fake 
Linux environment. The objective is to set a very common username and password to facilitate 
the access to an attacker.

\subsubsection{Cowrie and its configuration} % 634

\paragraph{} 

Cowrie is an SSH honeypot allowing its user to log brute force attacks and the entire shell 
command lines performed by attackers once logged on the server. Developed in Python by 
Michel Oosterhof, this project is a fork of another well known SSH honeypot called Kippo and
developed by desaster. Indeed, the developer of Cowrie decided to add many features such as
the addition of the "ssh exec commands" support. Indeed, it is possible to execute command 
lines through SSH after being connected or execute a single command line remotely, without 
obtaining a full shell but only the output of its command. This is commonly used by attackers 
that developed scripts to automate their attacks and is consequently useful to be implemented
on an SSH honeypot.
Moreover, because the attackers who access to cowrie is in a fake Linux environment jailed from
the rest of the real server operating systems, all command lines have to be re-implemented. 
Consequently, Kippo and then Cowrie honeypots have implemented commons command lines used by
attackers and more generally all Linux users. However, one of them called "ping", used to 
test the communication between two devices on a network allowed in Kippo to ping IP addresses
such as "555.555.555.555" which is an impossible IP address. Indeed, an IP address is composed
of 4 bytes and bytes can only store a value between 0 and 255. Hence, Kippo project is no longer
 maintained and some automate scripts used to detect this honeypot have been developed.

Consequently, I decided to use this SSH honeypot in order to collect attacks data. Its 
installation is really basic. First of all, a server accessible by a public IP address is 
needed. For my research, I choose to subscribe to a Virtual Private Server (VPS) on OVH, a French
servers provider. Unlike a dedicated server, a VPS is basically a virtual machine running on a
physical machine with a chosen operating systems. Its advantage is its low cost, because of
the multiple virtual machines that can be run at the same time on a single dedicated server
, associated with a sufficient configuration for a honeypot (2gigabytes of RAM and 10 
gigabytes of storage).

The second part consists of deploying the honeypot on this VPS. Cowrie is available on Github,
a website allowing to store developers projects on a private or public repository with versions
numbers. Hence, it just needed to install with the packet manager available on the chosen 
operating system the "git" command line in order to clone the cowrie repository. This previous
step implies to have created a user "cowrie" on your system, only use to run the honeypot.
Then, we have to install python and the associated libraries listed in the requirements.txt
file.
Once it has been done, the configuration file has to be edited to enable the MySQL database
storage of all data collected by the honeypot and also set the port number of the honeypot to
22. Indeed, the SSH service is by default set in port 22, consequently, the server has to be 
configured to ensure that the SSH honeypot run on port 22 and the original SSH server on a chosen
port. This step is essential to be sure to maintain an SSH access to monitor your server.

Before running this honeypot we can also define a list containing valid usernames and 
passwords to be connected to the server. Then, a shell script called "start.sh" has
to be executed to run the honeypot. More details about the installation and configuration
can be found easily on internet.

Finally, one important point is to ensure that the server use does not contain any sensitives
information. Indeed, this is a software and despite the availability of the code on
GitHub the authors cannot ensure that any vulnerabilities will be found.


\subsubsection{Kippograph and data vizualisation} % 369 

\paragraph{}

An SSH honeypot generate a large amount of data. These data may refer to all information
related to SSH connection attempts such as identifiers used and IP address used, but also
to all events when the attackers access to a shell on our server.
In the case of cowrie and Kippo Honeypots, all data are stored on a MySQL database automatically.
This database is structured in 8 tables (auth, clients, downloads, input, keyfingerprints,
sensors, sessions and ttylog). However, due to the quantity of attacks that can be received
on an SSH honeypots, it quickly became apparent that read information from a database were a 
difficult task.
Consequently, I decided to put in place a graphical interface allowing to extract and format
useful data contains on this database.

Moreover, its important to notice that Cowrie apply the same database structure as Kippo.
Hence, due to the large community of Kippo, I have been able to use Kippograph (v1.5.1), a
tool from their toolbox.
This tool is a web interface using the Libchart PHP chart drawing library that gathers multiple
libraries in order to build maps and graphs from given data. Consequently, this tool allowed me
to perform a daily analysis of the actual state of attacks performed against my server.
Indeed, a simple GET request to one of the 6 available pages (kippo-graph, kippo-input,
kippo-playlog, kippo-ip, kippo-geo and graph gallery), return several graphs and information
such as the actual number of login attempts and distinct source IP addresses, easy to understand
and interpret.

The installation is also simple and fast to implement. First of all, Kippograph is a web interface
consequently a webserver such as Apache or Nginx has to be installed on the server. Once, it
has been installed all of the source code, located on GitHub has to be downloaded on the web server
localization (by default /var/www/html). Then, the configuration file has to be edited to 
allow it to get data from the cowrie MySQL database.
Finally, this website has to be protected with all basic security rules such as a strong
password to avoid everyone to access to this information remotely. More details about
the installation and configuration can be found easily on internet.



\subsection{Malware string analyzer} % 101

\paragraph{}

By putting in place an SSH honeypot, I have been able to collect a large number of binary 
downloaded by attackers when there were connected to the server. Those executables and 
Linkable Format binaries, also called ELF binaries, contains hard coded strings on them.
Based on these strings I decided to implement a python script, called Malware Strings 
Analyser (MSA), used to extract and sort strings into categories. This allowed me to 
automate this task to all gathered binaries and consequently to focus on the analysis of 
data generated by this script. The source code and documentation are available on GitHub.

\subsubsection{Strings categories} % 410

\paragraph{}

The analysis of readable strings is useful in order to understand how works a malware
without running it, also called a static analysis. However, this could be done only if
binaries are not packed. Indeed, some malware developers can employ encryption algorithms
in order to hide the active part of the malware to bypass possible detections of them.
Moreover, if a binary is stripped then we could not be able to get readable
strings such as the name of variables and functions symbols. Indeed, ELF binaries are 
commonly compiled with debug information. However, developers can use compilers options in
order to remove all debug information in order to hide a maximum of information about their
functionalities (included libraries, functions used,...).

During my research, I divided strings that I found in 10 categories:
\begin{enumerate}[label=\arabic*.]
  \item IP addresses: it is possible to find hard coded IP addresses, with sometimes a port
  number (e.g. 93.174.89.143:23)
  \item Identifiers: some binaries contains strings which look like username/passwords,
  probably to perform a password guessing brute force attack on the compromised server.
  \item Command lines:  there are some strings that contain readable shell command line
  that could be executed by the malware.
  \item Url and files: it is possible to find strings that contain URL allowing to download
  a file, probably to update the malware remotely. Those URLs are often written into a command line string.
  \item Path: some binaries contains strings with the absolute path to a Linux binary or a
  file (e.g. /bin/sh)
  \item Symbols: when a binary is not stripped it is possible to get more specific
  information such as the name of used functions.
  \item Format string: this type of string consists of building string dynamically
  (e.g. \%d.\%d.\%d.\%d for an IP address). 
  \item Display message: some readable message contains error, success or helps message.
  Those string can help to understand functionalities of the malware.
  \item Sections: it is possible to get name of the program sections (e.g. .text, .data,
  .bss, ...).
  \item Other: Some other strings contain readable information but I was not able to 
  determine if they are useful and where they come from. This category also contains 
  some extracted strings with random character without sense.
\end{enumerate}

Consequently, Malware String Analyzer tool, extract all readable character contains in a binary
file, sort them depending on their groups and store them in an SQLite database.
Finally, it is important to notice that a malware's developer can also introduce incorrect
readable strings in order to hide the correct functioning of its malware.


\subsubsection{Strings extraction} % 53

\paragraph{}

%- Why extract them ?
%- For each grp (regex, command line, dict) define How MSA extract them.
%- Final MSA conclusion

Malware string analyzer tool is used to extract strings in order to find patterns and link 
between those information to perform a pre-analysis of a given binary file. This database
contining sorted string by binaries could be used to determine a percentage of chance that
a binary file is or not a malware.




\subsubsection{Virus total analysis} % 400

\paragraph{}

%- What is VT ?
%- Their API
%- Some strings are interesting to analyze with it
%- Implementation on MSA