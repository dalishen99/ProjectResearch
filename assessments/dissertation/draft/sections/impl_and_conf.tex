\subsection{Honeypots}

\paragraph{} % 70

As we have seen previously, the analysis of Linux servers attacks requires collecting the 
maximum of information about each of them. In order to perform this task, I choose to put 
in place a honeypot software called Cowrie \cite{cowrie}.
In this section will be explained how works a honeypot, how cowrie has to be configured and
finally how it is possible to extract useful attacks information from all collected data.

\subsubsection{Honeypots overview} % 421

\paragraph{}  

As seen during the literature and related works review, Honeypots are not a recent technique
and are still commonly used to trap attackers. Moreover, they can be used in multiple manners
to analyse different types of attacks. However, all of them are aimed at being undetectable 
by attackers. Indeed, honeypots software are built to receive attacks from real attackers
who wants to compromise a vulnerable machine and confine the attack to a controlled. 
environment. Hence, the configuration part of this type of tool and its security has to be
constantly monitored. A honeypot containing an unknown vulnerability (also called 0day) or
with incorrect settings, could be exploited by attackers and consequently lead
the machine to be compromised. 

Multiple systems can be used and some honeypots project, for instance, are able to be
installed on smartphones by using a tool such as HoneyDroid \cite{paperHoneyDroid}. Moreover, the HoneyNet Project \cite{honeynetProject}
gather security specialist that use multiple types of honeypots in order to collect data 
and report their knowledge about detected attacks on all platforms. They also developed 
various and sundry tools such as HoneySnap \cite{honeySnap}, a script used to extract malicious events from 
large logs generated by their honeypots, and allowing to understand attacker's methodology 
on the inside of the compromised system.

Honeypots can also be associated together and create HoneyNets. Unlike a honeypot that can
be installed on a system in production inside a complete network as a sensor or alone on a
a separate machine, a honeyNet is composed of multiple honeypots. Each of them can allow to
detect and analyse more complex attacks in a large network closer to reality for a company
than a single machine.

In order to be attacked, a honeypot has to be vulnerable and accessible remotely. There are a
large number of possible vulnerabilities depending on the system targeted. Each of them can
allow attackers to execute more or less critical tasks such as obtained a root access to
a server. A known honeypots technics, to perform this tasks, is to emulate a fake Secure Shell
(SSH) access. This service is used to obtain a remote secure shell from a server, in order
to monitor it. Indeed, this remote shell can be accessed by knowing a username and its 
associated password, available on the server. Once the honeypot emulates a fake SSH access it
will allow creating multiple valid identifiers allowing an attacker to access to a fake 
Linux environment. The objective is to set a very common username and password to facilitate 
the access to an attacker.

\subsubsection{Cowrie and its configuration} % 634

\paragraph{} 

Cowrie is an SSH honeypot allowing its user to log brute force attacks and the entire shell 
command lines performed by attackers once logged on the server. Developed in Python by 
Michel Oosterhof, this project is a fork of another well known SSH honeypot called Kippo \cite{kippo} and
developed by desaster. Indeed, the developer of Cowrie decided to add many features such as
the addition of the "ssh exec commands" support. Indeed, it is possible to execute command 
lines through SSH after being connected or execute a single command line remotely, without 
obtaining a full shell, but only the output of its command. This is commonly used by attackers 
that developed scripts to automate their attacks and is consequently useful to be implemented
on an SSH honeypot.
Moreover, because the attackers who access to cowrie is in a fake Linux environment jailed from
the rest of the real server operating systems, all command lines have to be re-implemented. 
Consequently, Kippo and then Cowrie honeypots have implemented commons command lines used by
attackers and more generally all Linux users. However, one of them called "ping", used to 
test the communication between two devices on a network allowed in Kippo to ping IP addresses
such as "555.555.555.555" which is an impossible IP address. Indeed, an IP address is composed
of 4 bytes and bytes can only store a value between 0 and 255. Hence, Kippo project is no longer
 maintained and some automate scripts used to detect this honeypot have been developed.

Consequently, I decided to use this SSH honeypot in order to collect attacks data. Its 
installation is really basic. First of all, a server accessible by a public IP address is 
needed. For my research, I choose to subscribe to a Virtual Private Server (VPS) on OVH \cite{ovh}, a French
servers provider. Unlike a dedicated server, a VPS is basically a virtual machine running on a
physical machine with a chosen operating systems. Its advantage is its low cost, because of
the multiple virtual machines that can be run at the same time on a single dedicated server
, associated with a sufficient configuration for a honeypot (2gigabytes of RAM and 10 
gigabytes of storage).

The second part consists of deploying the honeypot on this VPS. Cowrie is available on Github \cite{github},
a website allowing to store developers projects on a private or public repository with versions
numbers. Hence, it just needed to install with the packet manager available on the chosen 
operating system the "git" command line in order to clone the cowrie repository. This previous
step implies to have created a user "cowrie" on your system, only use to run the honeypot.
Then, we have to install python and the associated libraries listed in the requirements.txt
file.
Once it has been done, the configuration file has to be edited to enable the MySQL \cite{mysql} database
storage of all data collected by the honeypot and also set the port number of the honeypot to
22. Indeed, the SSH service is by default set in port 22, consequently, the server has to be 
configured to ensure that the SSH honeypot run on port 22 and the original SSH server on a chosen
port. This step is essential to be sure to maintain an SSH access to monitor your server.

Before running this honeypot we can also define a list containing valid usernames and 
passwords to be connected to the server. Then, a shell script called "start.sh" has
to be executed to run the honeypot. More details about the installation and configuration
can be found easily on internet.

Finally, one important point is to ensure that the server use does not contain any sensitives
information. Indeed, this is a software and despite the availability of the code on
GitHub the authors cannot ensure that any vulnerabilities will be found.


\subsubsection{Kippograph and data vizualisation} % 369 

\paragraph{}

An SSH honeypot generate a large amount of data. These data may refer to all information
related to SSH connection attempts such as identifiers used and IP address used, but also
to all events when the attackers access to a shell on our server.
In the case of cowrie and Kippo Honeypots, all data are stored on a MySQL database automatically.
This database is structured in 8 tables (auth, clients, downloads, input, keyfingerprints,
sensors, sessions and ttylog). However, due to the quantity of attacks that can be received
on an SSH honeypots, it quickly became apparent that read information from a database was a 
difficult task.
Consequently, I decided to put in place a graphical interface allowing to extract and format
useful data contains on this database.

Moreover, it is important to notice that Cowrie apply the same database structure as Kippo.
Hence, due to the large community of Kippo, I have been able to use Kippograph (v1.5.1) \cite{kippograph}, a
tool from their toolbox.
This tool is a web interface using the Libchart PHP chart drawing library that gathers multiple
libraries in order to build maps and graphs from given data. Consequently, this tool allowed me
to perform a daily analysis of the actual state of attacks performed against my server.
Indeed, a simple GET request to one of the 6 available pages (kippo-graph, kippo-input,
kippo-playlog, kippo-ip, kippo-geo and graph gallery), return several graphs and information
such as the actual Human activity per week (see Figure 1) and the number of 
connections per unique IP address with their country codes (see Figure 2), easy to
understand and interpret.

\importimg{./images/human_activity_per_week}{Human activity per week - Kippograph}{0.8}
\importimg{./images/connections_per_ip_geo.png}{Number of connections per unique IP address and country codes - Kippograph}{0.8}

The installation is also simple and fast to implement. First of all, Kippograph is a web interface
consequently a webserver such as Apache \cite{apache} or Nginx \cite{nginx} has to be installed on the server. Once, it
has been installed all of the source code, located on GitHub has to be downloaded on the web server
localisation (by default /var/www/html). Then, the configuration file has to be edited to 
allow it to get data from the cowrie MySQL database.
Finally, this website has to be protected with all basic security rules such as a strong
password to avoid everyone to access to this information remotely. More details about
the installation and configuration can be found easily on internet.



\subsection{Malware string analyzer} % 101

\paragraph{}

By putting in place an SSH honeypot, I have been able to collect a large number of binary 
downloaded by attackers when there were connected to the server. Those executables and 
Linkable Format binaries, also called ELF binaries, contains hard coded strings on them.
Based on these strings I decided to implement a python script, called Malware Strings 
Analyser (MSA) \cite{msa}, used to extract and sort strings into categories. This allowed me to 
automate this task to all gathered binaries and consequently to focus on the analysis of 
data generated by this script. The source code and documentation are available on GitHub.

\subsubsection{Strings categories} % 410

\paragraph{}

The analysis of readable strings is useful in order to understand how works a malware
without running it, also called a static analysis. However, this could be done only if
binaries are not packed. Indeed, some malware developers can employ encryption algorithms
in order to hide the active part of the malware to bypass possible detections of them.
Moreover, if a binary is stripped then we could not be able to get readable
strings such as the name of variables and functions symbols. Indeed, ELF binaries are 
commonly compiled with debug information. However, developers can use compilers options in
order to remove all debug information in order to hide a maximum of information about their
functionalities (included libraries, functions used,...).

During my research, I divided strings that I found in 10 categories:
\begin{enumerate}[label=\arabic*.]
  \item IP addresses: it is possible to find hard coded IP addresses, with sometimes a port
  number (e.g. 93.174.89.143:23)
  \item Identifiers: some binaries contains strings which look like username/passwords,
  probably to perform a password guessing brute force attack on the compromised server.
  \item Command lines:  there are some strings that contain readable shell command line
  that could be executed by the malware.
  \item Url and files: it is possible to find strings that contain URL allowing to download
  a file, probably to update the malware remotely. Those URLs are often written into a command line string.
  \item Path: some binaries contains strings with the absolute path to a Linux binary or a
  file (e.g. /bin/sh)
  \item Symbols: when a binary is not stripped it is possible to get more specific
  information such as the name of used functions.
  \item Format string: this type of string consists of building string dynamically
  (e.g. \%d.\%d.\%d.\%d for an IP address). 
  \item Display message: some readable message contains error, success or helps message.
  Those string can help to understand functionalities of the malware.
  \item Sections: it is possible to get name of the program sections (e.g. .text, .data,
  .bss, ...).
  \item Other: Some other strings contain readable information but I was not able to 
  determine if they are useful and where they come from. This category also contains 
  some extracted strings with random character without sense.
\end{enumerate}

Consequently, Malware String Analyzer tool, extract all readable character contains in a binary
file (see Figure 3), sort them depending on their groups and store them in an SQLite database \cite{sqlite}.
Finally, it is important to notice that a malware's developer can also introduce incorrect
readable strings in order to hide the correct functioning of its malware.

\importimg{./images/msa_processing.png}{Ouput string processing - Malware Strings Analyzer}{0.8}

\subsubsection{Strings extraction} % 656

\paragraph{}

Malware string analyser tool is used to extract strings in order to find patterns and link 
between those information and to perform a pre-analysis of a given binary file.
The generated database contains a table for each binary analysis with all strings sorted
by their type. Those data could be used to determine a percentage of chance that
a binary file is or not a malware.

In order to extract these strings, I determine basic criteria representing a string. Indeed,
a binary file is a basically a file containing bits (0 or 1). By grouping them into group of
8 bits we obtain a byte. This byte can contain values between 0 to 255, and consequently, it
can represent a character from the ASCII (American Standard Code for Information Interchange)
table. This table is a standard of character encoding and contains all characters necessary
to write in English. Based on it I decide to extract all readable character from this
list: \ \textbackslash : , [ ] \textless \textgreater \% \$ \_  and also the following: space, A to Z (in upper and lower case).
Hence, the malware string analyser script starts by opening a file and search for strings from 
the previously listed characters with a size of minimum 4 characters, one after the other.
The method to extract these data is called a regular expression which is a specific syntax 
that allow to match it with multiple corresponding strings.

This first step enables the script to collect all readable strings. Afterwards, a specific 
python function is applied for each string categories.
In order to code these sorting functions, I used the following 4 technics:
\begin{enumerate}
  \item Regular expression: as during the extraction of strings from a binary, some string
  are defined as belonging to categories by using a specific regular expression.
  Indeed, the categories IP addresses, URLs, Path, Format string and Sections are extracted
  from raw strings by formatting a specific regular expression.
  \item Specific python libraries: the "Display message" categories has been built by extracting
  strings with a python library called "Enchant". Indeed, it provides a function that allows determining if a given word is or not an English word. Based on that I was able to split all
  words from strings and compute a percentage of English words in a sentence and finally
  supposed that this string can be a message written by the malware developer. Moreover, 
  the "command line" categories have been build by using the "spawn" function from the distutils
  python library in order to determine if a given is a known Linux command line or not.
  \item Linux command lines: When python libraries were insufficient to sort strings into specific categories I executed Linux command lines through the malware strings analyser
  script. Indeed it is the case for the Symbols and command lines categories. Indeed, command 
  lines and symbols strings found by executing and then parsing the output of respectively
  the "command" and "readelf" \cite{readelf} Linux command lines.
  \item Dictionary lists: the Identifiers category is an only based on real user inputs.
  Consequently, strings from this category have been extracted by using two lists of usernames
  and passwords builds by using connection attempts data from Cowrie database.
\end{enumerate}

By using those four techniques, the malware strings analyser is able to create a table containing
for each raw strings, the interesting part of it and its type (name of the associated category).
For all other strings that don't match to a known category, they are noted as the "other" category.
Furthermore, it is important to notice that the malware string analyser execute all of these 
sorting function in a specific order. Indeed, each function browses all extracted raw strings
and remove from the list each string detected as belonging to a known categories.
Consequently, an optimise sequence has been built to obtain more reliable results.
For more information, the code of these sorting function is stored in the parser.py python
file in available on the malware string analyser GitHub \cite{msa}.

\subsubsection{Virus total analysis} % 603

\paragraph{}

The malware strings analyser scripts are in fact focused on strings extracted from potential
malware binaries, collected by Cowrie honeypot. However, in order to confirm that those
binaries were known malware, I decide to apply an external malware detection analysis
called Virus Total \cite{vt}. This web service provides a large database of known malware, supplied by 
all users that upload their suspect files into their website.
It is possible to upload a file on their platform to be analysed. Then, Virus Total
will compare this file to their database by using for instance Hashes of the analysed file.
Indeed, a hash is a mathematical algorithm that will generate a unique string which corresponds
to the print of a given file. Multiple algorithms can be used to perform this tasks with Virus
Total, but the currently allowed hash functions are MD5, SHA1 and SHA256. However, a hash is 
supposed to be unique, consequently, malware developers can introduce some minor modification
in their source code in order to modify the hash without modifying its behaviour.
By using this Hash virus total will return to the user data generated by a static analysis 
of this file if it has been already analysed. Moreover, it will submit it to a list of common
antivirus and provide a list of their results.

Furthermore, to automate the usage of this powerful tool, Virus Total team have developed
an API (Application Programming Interface), which allow developers to send HTTP requests to
their tool automatically from a program. This API is accessible by using an API key generated
during the creation of a Virus Total account. Those API key can be public or private and 
give an access to more or fewer functionalities. Despite the limited number of functionalities
in the public API compare to the private API, the real disadvantage of the public API is that
the number of requests is limited in the time. Indeed, users are restrained to a small
number of requests per minutes and days. This could be an issue for my research due to a large amount of binary to analyse automatically during my research. Consequently, I decided
to contact the Virus Total team that gave me a private API key in view of my project
research.

Hence, by using this Virus Total API key, the malware strings analyser provides a Virus Total options allowing to perform a global analysis of the file, before the strings analysis part.
This has been useful to classify extracted strings depending if they were from a known or a 
potential unknown malware.
Indeed, the aim of the malware string analyser tool is to generate a database containing 
strings sorted into categories from a given binary, but also to collect global data of this file.
Indeed, this will lead to apply data mining techniques from those gathered data, in order to
determine if a file is potentially a malware or not. Consequently, global binary information
collected during this steps are essential for future analysis.

Then, after the execution of the strings analysis steps, strings sorted as URLs and IP addresses
are analysed by using the Virus Total API. Indeed, Virus Total allow its users to submit
URL and IP addresses in order to determine if they are known as malicious activities.
Consequently, the malware strings analyser tool send requests for each strings define
as a URL or an IP address and provide the results in its output.
Returned information can allow determining if a found URL in a binary is known as a malware
binary host, or if an IP address is known as a command and control server for malware.
