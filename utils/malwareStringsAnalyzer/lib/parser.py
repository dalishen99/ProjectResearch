from distutils import spawn
from subprocess import PIPE, STDOUT
import re, enchant, subprocess

class Parser(object):
    """
        This class is used to perform all tasks concerning the string analysis.
    """

    @staticmethod
    def strings(path):
        """
            Extract all readable strings from a binary.

            :param path: Path to the binary to analyze.
            :type: string
            :return: List that contains all strings.
            :rtype: List
        """
        string_list = []
        chars = r"A-Za-z0-9/\-:.,_$%'()[\]<> "
        shortest_run = 4
        regexp = '[%s]{%d,}' % (chars, shortest_run)
        pattern = re.compile(regexp)
        try:
            with open(path, 'rb') as file:
                return pattern.findall(file.read())
        except:
            return None

    @staticmethod
    def getIp(string):
        """
            Static method that extract strings detected as an IP address.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """
        regexp = """\\b((?:\\b(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5])\\b:(?:6535[0-3]\\b|653[0-4]\\b|65[0-2]\d{2}|6[0-4]\d{3}|[1-5]\d{4}|[1-9]\d{3}|[1-9]\d{2}|[1-9]\d|\d)|\\b(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5])\\b))"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getUrl(string):
        """
            Static method that extract strings detected as an URL.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """
        regexp = """(?:(?:http|ftp) : //[^ ]+ : [^ ]+|(?:http|ftp) : //[^ ]+)|http[^ ]+"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getCmd(string):
        """
            Static method that extract strings detected as a linux command line.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """
        potential_cmd = string.replace(">", "o").replace("<", "o") \
                              .replace("]", "o").replace("[", "o") \
                              .replace("/", "o").replace("\\", "o") \
                              .replace("'", "o").replace("%", "o") \
                              .replace("-", "o").replace("_", "o") \
                              .replace(":", "o").replace(",", "o") \
                              .replace(".", "o") \
                              .lstrip().split(" ")[0]                            #   .replace(")", " ").replace("(", " ") \

        if spawn.find_executable(potential_cmd) != None:
            return potential_cmd

        cmd = ["bash -c \"command -v \"" + potential_cmd + "\"\""]
        ret = subprocess.Popen(cmd, shell=True, stdin=PIPE,
                                stdout=PIPE, stderr=STDOUT).communicate()
        if ret[0] != "" and potential_cmd not in ["(null)", "(nil)"]:
            return potential_cmd
        return None

    @staticmethod
    def getId(string):
        """
            Static method that extract strings detected as an identifier.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """

        dir = "../../collectedData/identifiers/"
        fuser = fpass = []
        with open(dir + "username") as f:
            fuser = f.read().splitlines()
            fuser = map(lambda x:x.lower(),fuser)
        with open(dir + "password") as f:
            fpass = f.read().splitlines()
            fpass = map(lambda x:x.lower(),fpass)
        if (string.lower() in fpass) or (string.lower() in fuser):
            return string
        return None

    @staticmethod
    def getPath(string):
        """
            Static method that extract strings detected as a file path.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """

        if "/" not in string or "(" in string or ")" in string:
            return None

        bad_seq = ["//", "i/o", "input/output"]
        for seq in bad_seq:
            if seq in string.lower():
                return None
        regexp = """(.*[\\\/]|^)(.*?)(?:[\.]|$)([^\.\s]*$)"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getSection(string):
        """
            Static method that extract strings detected as a elf binary section.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """

        regexp = """^\.[a-zA-Z0-9_]+$"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getSymbol(string, readelf_output):
        for entry in readelf_output:
            entry = re.sub(r'\s+', ' ', entry).strip().split()
            if len(entry) == 8 and entry[3] != "NOTYPE" \
                and string == entry[-1]:
                return string, entry[3].lower()
        return None, None

    @staticmethod
    def getFormatStr(string):
        """
            Static method that extract strings detected as a format string.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """

        regexp = """%[\-\+0\s\#]{0,1}(\d+){0,1}(\.\d+){0,1}[hlI]{0,1}[cCdiouxXeEfgGnpsS]{1}"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getMessage(string):
        """
            Static method that extract strings detected as an english message.

            :param string: A string to be analyzed.
            :type string: String
            :return: None if the string doesn't match or the part of the string
                     which corresponds.
            :rtype: string
        """

        sentence_list = re.sub(r'\s+', ' ', string).strip().split()
        d = enchant.Dict("en_US")
        known_words = 0
        for word in sentence_list:
            if d.check(word):
                known_words += 1
        percent = (100 * known_words) / len(sentence_list)
        if percent < 60:
            return None
        return string

    @staticmethod
    def isValidBin(path):
        """
            Detect if a file is an elf binary.

            :param path: Absolute path to an elf binary.
            :type path: string
            :return: First value determine if its a binary or not and the second
                     contains the error message in case of error.
            :rtype: Boolean, string
        """
        cmd = ["bash -c \"file \"" + path + "\"\""]
        ret = subprocess.Popen(cmd, shell=True, stdin=PIPE,
                                stdout=PIPE, stderr=STDOUT).communicate()
        if "not stripped" not in ret[0]:
            return False, "[Error] stripped binary, impossible to perform string analysis."
        if "too many section" in ret[0]:
            return False, "[Error] too many section, impossible to perform string analysis."
        return True, None
