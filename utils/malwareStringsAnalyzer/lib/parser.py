from mmap import mmap, PROT_READ
from distutils import spawn
import re
import enchant
import subprocess
from subprocess import PIPE, STDOUT

class Parser(object):
    def __init__(self):
        pass


    @staticmethod
    def strings(path):
        string_list = []
        chars = r"A-Za-z0-9/\-:.,_$%'()[\]<> "
        shortest_run = 4
        regexp = '[%s]{%d,}' % (chars, shortest_run)
        pattern = re.compile(regexp)
        try:
            with open(path, 'rb') as file:
                return pattern.findall(file.read())
        except:
            return None

    @staticmethod
    def getIp(string):
        regexp = """\\b((?:\\b(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5])\\b:(?:6535[0-3]\\b|653[0-4]\\b|65[0-2]\d{2}|6[0-4]\d{3}|[1-5]\d{4}|[1-9]\d{3}|[1-9]\d{2}|[1-9]\d|\d)|\\b(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5])\\b))"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getUrl(string):
        regexp = """(?:(?:http|ftp) : //[^ ]+ : [^ ]+|(?:http|ftp) : //[^ ]+)|http[^ ]+"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getCmd(string):
        potential_cmd = string.replace(">", "") \
                              .replace("<", "") \
                              .lstrip().split(" ")[0]
        if spawn.find_executable(potential_cmd) != None:
            return potential_cmd

        cmd = ["bash -c \"command -v \"" + potential_cmd + "\"\""]
        ret = subprocess.Popen(cmd, shell=True, stdin=PIPE,
                                stdout=PIPE, stderr=STDOUT).communicate()
        if ret[0] != "" and potential_cmd not in ["(null)", "(nil)"]:
            return potential_cmd
        return None

    @staticmethod
    def getId(string):
        dir = "../../collectedData/identifiers/"
        fuser = fpass = []
        with open(dir + "username") as f:
            fuser = f.read().splitlines()
            fuser = map(lambda x:x.lower(),fuser)
        with open(dir + "password") as f:
            fpass = f.read().splitlines()
            fpass = map(lambda x:x.lower(),fpass)
        if (string.lower() in fpass) or (string.lower() in fuser):
            return string
        return None

    @staticmethod
    def getPath(string):
        if "/" not in string:
            return None

        bad_seq = ["//", "i/o", "input/output"]
        for seq in bad_seq:
            if seq in string.lower():
                return None
        regexp = """(.*[\\\/]|^)(.*?)(?:[\.]|$)([^\.\s]*$)"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getSection(string):
        regexp = """^\.[a-zA-Z0-9_]+$"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getSymbol(string, readelf_output):
        for entry in readelf_output:
            entry = re.sub(r'\s+', ' ', entry).strip().split()
            if len(entry) == 8 and entry[3] != "NOTYPE" \
                and string == entry[-1]:
                return string, entry[3].lower()
        return None, None

    @staticmethod
    def getFormatStr(string):
        regexp = """%[\-\+0\s\#]{0,1}(\d+){0,1}(\.\d+){0,1}[hlI]{0,1}[cCdiouxXeEfgGnpsS]{1}"""
        pattern = re.compile(regexp)
        if pattern.search(string) is None:
            return None
        return pattern.search(string).group()

    @staticmethod
    def getMessage(string):
        sentence_list = re.sub(r'\s+', ' ', string).strip().split()
        d = enchant.Dict("en_US")
        known_words = 0
        for word in sentence_list:
            if d.check(word):
                known_words += 1
        percent = (100 * known_words) / len(sentence_list)
        if percent < 60:
            return None
        return string
